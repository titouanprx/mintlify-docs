import { getOpenApiTitleAndDescription, optionallyAddLeadingSlash, slugToTitle, validate, } from '@mintlify/common';
import fse, { outputFile } from 'fs-extra';
import fs from 'fs/promises';
import yaml from 'js-yaml';
import { OpenAPIV3 } from 'openapi-types';
import { join, resolve, parse } from 'path';
import path from 'path';
import { fetchOpenApi } from '../utils/network.js';
export const getOpenApiDefinition = async (pathOrDocumentOrUrl) => {
    if (typeof pathOrDocumentOrUrl === 'string') {
        if (pathOrDocumentOrUrl.startsWith('http://')) {
            // This is an invalid location either for a file or a URL
            throw new Error('Only HTTPS URLs are supported. Please provide an HTTPS URL');
        }
        else {
            try {
                const url = new URL(pathOrDocumentOrUrl);
                pathOrDocumentOrUrl = url;
            }
            catch {
                const pathname = path.join(process.cwd(), pathOrDocumentOrUrl.toString());
                const file = await fs.readFile(pathname, 'utf-8');
                pathOrDocumentOrUrl = yaml.load(file);
            }
        }
    }
    const isUrl = pathOrDocumentOrUrl instanceof URL;
    if (pathOrDocumentOrUrl instanceof URL) {
        if (pathOrDocumentOrUrl.protocol !== 'https:') {
            throw new Error('Only HTTPS URLs are supported. Please provide an HTTPS URL');
        }
        pathOrDocumentOrUrl = await fetchOpenApi(pathOrDocumentOrUrl);
    }
    return { document: pathOrDocumentOrUrl, isUrl };
};
export const generateOpenApiPages = async (pathOrDocumentOrUrl, opts) => {
    const { openApiFilePath, version, writeFiles, outDir, outDirBasePath } = opts ?? {};
    const openApiFilePathFromRoot = openApiFilePath
        ? optionallyAddLeadingSlash(openApiFilePath)
        : undefined;
    const { document, isUrl } = await getOpenApiDefinition(pathOrDocumentOrUrl);
    const { schema } = await validate(document);
    if (schema?.paths === undefined || Object.keys(schema.paths).length === 0) {
        throw new Error('No paths defined.');
    }
    const nav = [];
    const decoratedNav = [];
    const writePromises = [];
    const pagesAcc = {};
    Object.entries(schema.paths).forEach(([path, pathItemObject]) => {
        if (!pathItemObject || typeof pathItemObject !== 'object') {
            return;
        }
        const typedPathItemObject = pathItemObject;
        Object.values(OpenAPIV3.HttpMethods).forEach((method) => {
            if (method in typedPathItemObject) {
                const operation = typedPathItemObject[method];
                const groupName = operation?.tags?.[0];
                const title = prepareStringToBeValidFilename(operation?.summary) ??
                    `${method}-${prepareStringToBeValidFilename(path)}`;
                const folder = prepareStringToBeValidFilename(groupName) ?? '';
                const base = join(outDir ?? '', folder, title);
                const navGroup = findNavGroup(nav, groupName);
                const decoratedNavGroup = findNavGroup(decoratedNav, groupName);
                const filenameWithoutExtension = generateUniqueFilenameWithoutExtension(navGroup, base);
                const openapiMetaTag = `${openApiFilePathFromRoot ? `${openApiFilePathFromRoot} ` : ''}${method} ${path}`;
                const { title: titleTag, description } = getOpenApiTitleAndDescription([
                    {
                        filename: openApiFilePath ? parse(openApiFilePath).name : 'filler-filename',
                        spec: schema,
                        originalFileLocation: openApiFilePath,
                    },
                ], openapiMetaTag);
                navGroup.push(filenameWithoutExtension);
                const page = {
                    openapi: openapiMetaTag,
                    href: resolve('/', filenameWithoutExtension),
                    title: titleTag ?? slugToTitle(filenameWithoutExtension),
                    description,
                    version,
                };
                decoratedNavGroup.push(page);
                pagesAcc[filenameWithoutExtension] = page;
                const targetPath = outDirBasePath
                    ? join(outDirBasePath, `${filenameWithoutExtension}.mdx`)
                    : `${filenameWithoutExtension}.mdx`;
                if (writeFiles && (!fse.pathExistsSync(targetPath) || opts?.overwrite)) {
                    writePromises.push(createOpenApiFrontmatter(targetPath, openapiMetaTag, version));
                }
            }
        });
    });
    await Promise.all(writePromises);
    return {
        nav,
        decoratedNav,
        spec: schema,
        pagesAcc,
        isUrl,
    };
};
// returns the group with the given group name, or the top-level group if no group name is provided
const findNavGroup = (nav, groupName) => {
    if (groupName === undefined) {
        groupName = 'API Reference';
    }
    const group = nav.find((fileOrGroup) => typeof fileOrGroup === 'object' && 'group' in fileOrGroup && fileOrGroup.group === groupName);
    if (group === undefined) {
        const newGroup = {
            group: groupName,
            pages: [],
        };
        nav.push(newGroup);
        return newGroup.pages;
    }
    else {
        return group.pages;
    }
};
// returns a filename that is unique within the given array of pages
const generateUniqueFilenameWithoutExtension = (pages, base) => {
    let filename = base;
    if (pages.includes(filename)) {
        let extension = 1;
        filename = `${base}-${extension}`;
        while (pages.includes(filename)) {
            extension += 1;
            filename = `${base}-${extension}`;
        }
    }
    return filename;
};
const createOpenApiFrontmatter = async (filename, openApiMetaTag, version) => {
    const data = `---
openapi: ${openApiMetaTag}${version ? `\nversion: ${version}` : ''}
---`;
    await outputFile(filename, data);
};
export const prepareStringToBeValidFilename = (str) => str
    ? str
        .replaceAll(' ', '-')
        .replace(/\{.*?\}/g, '-') // remove path parameters
        .replace(/^-/, '')
        .replace(/-$/, '')
        .replace(/[{}(),.'\n\/]/g, '') // remove special characters
        .replaceAll(/--/g, '-') // replace double hyphens
        .toLowerCase()
    : undefined;
//# sourceMappingURL=generateOpenApiPages.js.map