import {
  getOpenApiTitleAndDescription,
  optionallyAddLeadingSlash,
  slugToTitle,
  validate,
} from '@mintlify/common';
import type {
  DecoratedNavigation,
  DecoratedNavigationGroup,
  Navigation,
  NavigationEntry,
  NavigationGroup,
  DecoratedNavigationPage,
} from '@mintlify/models';
import fse, { outputFile } from 'fs-extra';
import fs from 'fs/promises';
import yaml from 'js-yaml';
import { OpenAPI, OpenAPIV3 } from 'openapi-types';
import { join, resolve, parse } from 'path';
import path from 'path';

import { fetchOpenApi } from '../utils/network.js';

export const getOpenApiDefinition = async (
  pathOrDocumentOrUrl: string | OpenAPI.Document | URL
): Promise<{ document: OpenAPI.Document; isUrl: boolean }> => {
  if (typeof pathOrDocumentOrUrl === 'string') {
    if (pathOrDocumentOrUrl.startsWith('http://')) {
      // This is an invalid location either for a file or a URL
      throw new Error('Only HTTPS URLs are supported. Please provide an HTTPS URL');
    } else {
      try {
        const url = new URL(pathOrDocumentOrUrl);
        pathOrDocumentOrUrl = url;
      } catch {
        const pathname = path.join(process.cwd(), pathOrDocumentOrUrl.toString());
        const file = await fs.readFile(pathname, 'utf-8');
        pathOrDocumentOrUrl = yaml.load(file) as OpenAPI.Document;
      }
    }
  }

  const isUrl = pathOrDocumentOrUrl instanceof URL;
  if (pathOrDocumentOrUrl instanceof URL) {
    if (pathOrDocumentOrUrl.protocol !== 'https:') {
      throw new Error('Only HTTPS URLs are supported. Please provide an HTTPS URL');
    }
    pathOrDocumentOrUrl = await fetchOpenApi(pathOrDocumentOrUrl);
  }

  return { document: pathOrDocumentOrUrl as OpenAPI.Document, isUrl };
};

export const generateOpenApiPages = async (
  pathOrDocumentOrUrl: string | OpenAPI.Document | URL,
  opts?: {
    openApiFilePath?: string | undefined;
    version?: string | undefined;
    writeFiles?: boolean;
    outDir?: string;
    outDirBasePath?: string;
    overwrite?: boolean;
  }
): Promise<{
  nav: Navigation;
  decoratedNav: DecoratedNavigation;
  spec: OpenAPI.Document;
  pagesAcc: Record<string, DecoratedNavigationPage>;
  isUrl: boolean;
}> => {
  const { openApiFilePath, version, writeFiles, outDir, outDirBasePath } = opts ?? {};
  const openApiFilePathFromRoot = openApiFilePath
    ? optionallyAddLeadingSlash(openApiFilePath)
    : undefined;

  const { document, isUrl } = await getOpenApiDefinition(pathOrDocumentOrUrl);

  const { schema } = await validate(document);

  if (schema?.paths === undefined || Object.keys(schema.paths).length === 0) {
    throw new Error('No paths defined.');
  }

  const nav: Navigation = [];
  const decoratedNav: DecoratedNavigation = [];
  const writePromises: Promise<void>[] = [];
  const pagesAcc: Record<string, DecoratedNavigationPage> = {};
  Object.entries(schema.paths).forEach(([path, pathItemObject]) => {
    if (!pathItemObject || typeof pathItemObject !== 'object') {
      return;
    }
    const typedPathItemObject = pathItemObject as OpenAPIV3.PathItemObject;
    Object.values(OpenAPIV3.HttpMethods).forEach((method) => {
      if (method in typedPathItemObject) {
        const operation = typedPathItemObject[method];
        const groupName = operation?.tags?.[0];
        const title =
          prepareStringToBeValidFilename(operation?.summary) ??
          `${method}-${prepareStringToBeValidFilename(path)}`;
        const folder = prepareStringToBeValidFilename(groupName) ?? '';
        const base = join(outDir ?? '', folder, title);

        const navGroup = findNavGroup<NavigationGroup>(nav, groupName);
        const decoratedNavGroup = findNavGroup<DecoratedNavigationGroup>(decoratedNav, groupName);

        const filenameWithoutExtension = generateUniqueFilenameWithoutExtension(navGroup, base);
        const openapiMetaTag = `${
          openApiFilePathFromRoot ? `${openApiFilePathFromRoot} ` : ''
        }${method} ${path}`;
        const { title: titleTag, description } = getOpenApiTitleAndDescription(
          [
            {
              filename: openApiFilePath ? parse(openApiFilePath).name : 'filler-filename',
              spec: schema as OpenAPI.Document,
              originalFileLocation: openApiFilePath,
            },
          ],
          openapiMetaTag
        );
        navGroup.push(filenameWithoutExtension);
        const page: DecoratedNavigationPage = {
          openapi: openapiMetaTag,
          href: resolve('/', filenameWithoutExtension),
          title: titleTag ?? slugToTitle(filenameWithoutExtension),
          description,
          version,
        };
        decoratedNavGroup.push(page);
        pagesAcc[filenameWithoutExtension] = page;
        const targetPath = outDirBasePath
          ? join(outDirBasePath, `${filenameWithoutExtension}.mdx`)
          : `${filenameWithoutExtension}.mdx`;
        if (writeFiles && (!fse.pathExistsSync(targetPath) || opts?.overwrite)) {
          writePromises.push(createOpenApiFrontmatter(targetPath, openapiMetaTag, version));
        }
      }
    });
  });

  await Promise.all(writePromises);

  return {
    nav,
    decoratedNav,
    spec: schema as OpenAPI.Document,
    pagesAcc,
    isUrl,
  };
};

// returns the group with the given group name, or the top-level group if no group name is provided
const findNavGroup = <T extends NavigationGroup | DecoratedNavigationGroup>(
  nav: T['pages'][number][],
  groupName?: string
): T['pages'][number][] => {
  if (groupName === undefined) {
    groupName = 'API Reference';
  }
  const group = nav.find(
    (fileOrGroup) =>
      typeof fileOrGroup === 'object' && 'group' in fileOrGroup && fileOrGroup.group === groupName
  ) as T | undefined;
  if (group === undefined) {
    const newGroup = {
      group: groupName,
      pages: [],
    };
    nav.push(newGroup);
    return newGroup.pages;
  } else {
    return group.pages;
  }
};

// returns a filename that is unique within the given array of pages
const generateUniqueFilenameWithoutExtension = (pages: NavigationEntry[], base: string): string => {
  let filename = base;
  if (pages.includes(filename)) {
    let extension = 1;
    filename = `${base}-${extension}`;
    while (pages.includes(filename)) {
      extension += 1;
      filename = `${base}-${extension}`;
    }
  }
  return filename;
};

const createOpenApiFrontmatter = async (
  filename: string,
  openApiMetaTag: string,
  version?: string
) => {
  const data = `---
openapi: ${openApiMetaTag}${version ? `\nversion: ${version}` : ''}
---`;

  await outputFile(filename, data);
};

export const prepareStringToBeValidFilename = (str?: string) =>
  str
    ? str
        .replaceAll(' ', '-')
        .replace(/\{.*?\}/g, '-') // remove path parameters
        .replace(/^-/, '')
        .replace(/-$/, '')
        .replace(/[{}(),.'\n\/]/g, '') // remove special characters
        .replaceAll(/--/g, '-') // replace double hyphens
        .toLowerCase()
    : undefined;
