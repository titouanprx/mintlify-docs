import _ from 'lodash';
const DEFAULT_TAB = {
    tab: 'Documentation',
};
const DEFAULT_ANCHOR = {
    anchor: 'Documentation',
    icon: 'book-open',
    hidden: true,
};
const filterGroupsByVersion = (groups, versionName) => groups.filter((group) => group.version === versionName || group.version === undefined || !versionName);
const formatIcon = (icon, iconType) => iconType ? { name: icon, style: iconType } : icon;
const isAnchor = (division) => 'icon' in division || 'color' in division;
const isRemoteUrl = (url) => {
    if (!url)
        return false;
    return url.startsWith('https://') || url.startsWith('http://');
};
/**
 * Get global divisions from config
 * 1. External links
 * 2. always there
 */
const getGlobalDivisions = (config) => {
    const { tabs, anchors, versions } = config;
    const globalConfig = {};
    if ((versions === null || versions === void 0 ? void 0 : versions.length) &&
        versions.every((version) => typeof version === 'object' && isRemoteUrl(version.url)))
        globalConfig.versions = versions.map((version) => ({
            version: version.name,
            href: version.url,
        }));
    if ((tabs === null || tabs === void 0 ? void 0 : tabs.length) && tabs.every((tab) => !tab.version && isRemoteUrl(tab.url))) {
        globalConfig.tabs = tabs.map((tab) => (Object.assign(Object.assign({ tab: tab.name, href: tab.url }, (tab.isDefaultHidden ? { hidden: tab.isDefaultHidden } : {})), (tab.openapi ? { openapi: tab.openapi } : {}))));
    }
    if ((anchors === null || anchors === void 0 ? void 0 : anchors.length) && anchors.every((anchor) => !anchor.version && isRemoteUrl(anchor.url))) {
        globalConfig.anchors = anchors.map((anchor) => (Object.assign(Object.assign(Object.assign(Object.assign({ anchor: anchor.name, href: anchor.url }, (anchor.icon ? { icon: formatIcon(anchor.icon, anchor.iconType) } : {})), (typeof anchor.color === 'string'
            ? { color: { light: anchor.color, dark: anchor.color } }
            : {})), (anchor.isDefaultHidden ? { hidden: anchor.isDefaultHidden } : {})), (anchor.openapi ? { openapi: anchor.openapi } : {}))));
    }
    return globalConfig;
};
const findPagesForPrefix = (groups, division, versionName) => {
    const matchedGroups = [];
    const unmatchedGroups = [];
    const prefix = division === null || division === void 0 ? void 0 : division.url;
    if (isRemoteUrl(prefix)) {
        return { matchedGroups, unmatchedGroups: groups };
    }
    groups.forEach((group) => {
        const groupPages = [];
        const unmatchedGroupPages = [];
        const isGroupVersionMatch = group.version === versionName || group.version === undefined || !versionName;
        if (isGroupVersionMatch) {
            group.pages.forEach((page) => {
                if (typeof page === 'string') {
                    if (!prefix || page.startsWith(prefix)) {
                        groupPages.push(page);
                    }
                    else {
                        unmatchedGroupPages.push(page);
                    }
                }
                else {
                    const { matchedGroups: nestedGroups, unmatchedGroups: nestedUnmatchedGroups } = findPagesForPrefix([page], division, versionName);
                    groupPages.push(...nestedGroups);
                    if (nestedUnmatchedGroups.length) {
                        unmatchedGroupPages.push(page);
                    }
                }
            });
        }
        if (groupPages.length) {
            matchedGroups.push(Object.assign(Object.assign({ group: group.group }, (group.icon ? { icon: formatIcon(group.icon, group.iconType) } : {})), { pages: groupPages }));
        }
        if (unmatchedGroupPages.length) {
            unmatchedGroups.push(Object.assign(Object.assign({}, group), { pages: unmatchedGroupPages }));
        }
    });
    return { matchedGroups, unmatchedGroups };
};
const processDivisions = (type, divisions = [], navigationGroups = [], shouldInsertRemainingGroups = false, versionName, config) => {
    var _a, _b;
    let remainingGroups = filterGroupsByVersion(navigationGroups, versionName);
    const result = divisions
        .map((division) => {
        if (division.version !== versionName && versionName && division.version) {
            return undefined;
        }
        const baseDivision = Object.assign(Object.assign(Object.assign(Object.assign({}, (type === 'tabs' ? { tab: division.name } : { anchor: division.name })), { href: division.url }), (division.isDefaultHidden ? { hidden: division.isDefaultHidden } : {})), (division.openapi ? { openapi: division.openapi } : {}));
        if (isAnchor(division)) {
            if (division.icon) {
                baseDivision.icon = formatIcon(division.icon, division.iconType);
            }
            if (division.color) {
                baseDivision.color = division.color;
            }
        }
        const { matchedGroups, unmatchedGroups } = findPagesForPrefix(remainingGroups, division, versionName);
        remainingGroups = unmatchedGroups;
        if (matchedGroups.length) {
            return Object.assign(Object.assign({}, _.omit(baseDivision, 'href')), { groups: matchedGroups });
        }
        return baseDivision;
    })
        .filter(Boolean);
    if (remainingGroups.length && shouldInsertRemainingGroups) {
        const { matchedGroups } = findPagesForPrefix(remainingGroups, undefined, versionName);
        if (type === 'tabs') {
            result.unshift(Object.assign(Object.assign({}, (((_a = config === null || config === void 0 ? void 0 : config.primaryTab) === null || _a === void 0 ? void 0 : _a.name)
                ? Object.assign({ tab: config.primaryTab.name }, (config.primaryTab.isDefaultHidden !== undefined && {
                    hidden: config.primaryTab.isDefaultHidden,
                })) : DEFAULT_TAB)), { groups: matchedGroups }));
        }
        else {
            result.push(Object.assign(Object.assign({}, (((_b = config === null || config === void 0 ? void 0 : config.topAnchor) === null || _b === void 0 ? void 0 : _b.name) ? { anchor: config.topAnchor.name } : DEFAULT_ANCHOR)), { groups: matchedGroups }));
        }
    }
    if (type === 'tabs') {
        return { tabs: result, anchors: [], remainingGroups };
    }
    return { anchors: result, tabs: [], remainingGroups };
};
const findPagesForVersionOrLanguage = (groups, version, prefixes) => {
    const matchedGroups = [];
    groups.forEach((group) => {
        const groupPages = [];
        if (group.version === version || group.version === undefined) {
            group.pages.forEach((page) => {
                if (typeof page === 'string') {
                    const isGatedByDivision = Object.entries(prefixes).some(([href, versions]) => versions.includes(version) && page.startsWith(href));
                    if (isGatedByDivision || Object.keys(prefixes).some((href) => !page.startsWith(href))) {
                        groupPages.push(page);
                    }
                }
                else {
                    const { matchedGroups: nestedGroups } = findPagesForVersionOrLanguage([page], version, prefixes);
                    groupPages.push(...nestedGroups);
                }
            });
        }
        if (groupPages.length) {
            matchedGroups.push(Object.assign(Object.assign({ group: group.group }, (group.icon ? { icon: formatIcon(group.icon, group.iconType) } : {})), { pages: groupPages }));
        }
    });
    return { matchedGroups };
};
const processVersionsOrLanguages = (versions = [], navigationGroups = [], prefixes) => {
    const isLocale = versions.every((version) => typeof version === 'object' && version.locale);
    const result = versions.map((version) => {
        if (isLocale && typeof version === 'object' && version.locale) {
            const baseLanguage = {
                language: version.locale,
            };
            const { matchedGroups } = findPagesForVersionOrLanguage(navigationGroups, version.name, prefixes);
            return Object.assign(Object.assign({}, baseLanguage), { groups: matchedGroups });
        }
        else {
            const versionName = typeof version === 'string' ? version : version.name;
            const baseVersion = {
                version: versionName,
            };
            const { matchedGroups } = findPagesForVersionOrLanguage(navigationGroups, versionName, prefixes);
            return Object.assign(Object.assign({}, baseVersion), { groups: matchedGroups });
        }
    });
    return {
        isLocale,
        versions: result,
    };
};
/**
 * Priority
 * 1. versions (including locales)
 * 2. anchors (global anchors)
 * 3. tabs (tabs)
 * 4. groups
 */
export const updateNavigationToDocsConfig = (config) => {
    const { navigation: groups, tabs, anchors, versions } = config;
    const { tabs: globalTabs, anchors: globalAnchors, versions: globalVersions, } = getGlobalDivisions(config);
    // process divisions
    const getUpdatedNavigation = (groups, tabs, anchors, versionName, config) => {
        var _a, _b;
        if ((anchors === null || anchors === void 0 ? void 0 : anchors.length) && !(globalAnchors === null || globalAnchors === void 0 ? void 0 : globalAnchors.length)) {
            const { anchors: anchorsResult, remainingGroups } = processDivisions('anchors', anchors, groups, false, versionName, config);
            if (remainingGroups.length) {
                if ((tabs === null || tabs === void 0 ? void 0 : tabs.length) && !(globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length)) {
                    const { tabs: tabsResult } = processDivisions('tabs', tabs, remainingGroups, true, versionName, config);
                    anchorsResult.push(Object.assign(Object.assign({}, (((_a = config === null || config === void 0 ? void 0 : config.topAnchor) === null || _a === void 0 ? void 0 : _a.name) ? { anchor: config.topAnchor.name } : DEFAULT_ANCHOR)), { tabs: tabsResult }));
                }
                else {
                    const { matchedGroups } = findPagesForPrefix(remainingGroups, undefined, versionName);
                    anchorsResult.push(Object.assign(Object.assign({}, (((_b = config === null || config === void 0 ? void 0 : config.topAnchor) === null || _b === void 0 ? void 0 : _b.name) ? { anchor: config.topAnchor.name } : DEFAULT_ANCHOR)), { groups: matchedGroups }));
                }
            }
            return { anchors: anchorsResult };
        }
        if ((tabs === null || tabs === void 0 ? void 0 : tabs.length) && !(globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length)) {
            const { tabs: tabsResult } = processDivisions('tabs', tabs, groups, true, versionName, config);
            return { tabs: tabsResult };
        }
        if (groups.length) {
            const parsedGroups = filterGroupsByVersion(groups, versionName).map((group) => (Object.assign({ group: group.group, pages: group.pages }, (group.icon ? { icon: formatIcon(group.icon, group.iconType) } : {}))));
            return { groups: parsedGroups };
        }
        return undefined;
    };
    if ((versions === null || versions === void 0 ? void 0 : versions.length) && !(globalVersions === null || globalVersions === void 0 ? void 0 : globalVersions.length)) {
        const prefixes = versions.reduce((acc, version) => {
            const versionName = typeof version === 'string' ? version : version.name;
            const anchorPrefixes = anchors === null || anchors === void 0 ? void 0 : anchors.filter((anchor) => anchor.version === versionName && !isRemoteUrl(anchor.url));
            const tabPrefixes = tabs === null || tabs === void 0 ? void 0 : tabs.filter((tab) => tab.version === versionName && !isRemoteUrl(tab.url));
            anchorPrefixes === null || anchorPrefixes === void 0 ? void 0 : anchorPrefixes.forEach((anchor) => (acc[anchor.url] = [...(acc[anchor.url] || []), versionName]));
            tabPrefixes === null || tabPrefixes === void 0 ? void 0 : tabPrefixes.forEach((tab) => (acc[tab.url] = [...(acc[tab.url] || []), versionName]));
            return acc;
        }, {});
        const { versions: versionsResult, isLocale } = processVersionsOrLanguages(versions, groups, prefixes);
        versionsResult.forEach((version, index) => {
            var _a;
            const versionName = typeof versions[index] === 'string'
                ? version.version
                : ((_a = versions[index]) === null || _a === void 0 ? void 0 : _a.name) || version.language;
            const updatedNavigationPerVersion = getUpdatedNavigation(version.groups, tabs, anchors, versionName, config);
            if (updatedNavigationPerVersion) {
                versionsResult[index] = Object.assign(Object.assign({}, _.omit(version, 'groups')), updatedNavigationPerVersion);
            }
        });
        const navigationConfig = (isLocale ? { languages: versionsResult } : { versions: versionsResult });
        if ((globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length) || (globalAnchors === null || globalAnchors === void 0 ? void 0 : globalAnchors.length)) {
            navigationConfig.global = Object.assign(Object.assign({}, ((globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length) ? { tabs: globalTabs } : {})), ((globalAnchors === null || globalAnchors === void 0 ? void 0 : globalAnchors.length) ? { anchors: globalAnchors } : {}));
        }
        return navigationConfig;
    }
    const navigationConfig = (getUpdatedNavigation(groups, tabs, anchors, undefined, config) || {
        groups: [],
    });
    if ((globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length) || (globalAnchors === null || globalAnchors === void 0 ? void 0 : globalAnchors.length)) {
        navigationConfig.global = Object.assign(Object.assign({}, ((globalTabs === null || globalTabs === void 0 ? void 0 : globalTabs.length) ? { tabs: globalTabs } : {})), ((globalAnchors === null || globalAnchors === void 0 ? void 0 : globalAnchors.length) ? { anchors: globalAnchors } : {}));
    }
    return navigationConfig;
};
